# ğŸ® Kahoot-Style AI Trivia Game â€” Project Plan

A real-time multiplayer trivia game inspired by Kahoot. **Play with Friends** pits players against each other across 15 timed questions â€” scoring rewards both accuracy and speed. **Solo Mode** lets you play endlessly and climb a persistent global leaderboard. Questions are generated by the Claude API. Built with React, Node.js, Socket.io, and PostgreSQL.

---

## ğŸ› ï¸ Tech Stack

| Layer | Technology | Why |
|---|---|---|
| Frontend | React + Tailwind CSS | Component-based UI with utility-first styling |
| Backend | Node.js + Express | JavaScript everywhere, non-blocking I/O for real-time |
| Real-time | Socket.io | Abstracts WebSockets with reconnection and room support |
| Database | PostgreSQL | Reliable relational storage for users, scores, and questions |
| AI | Anthropic Claude API | Generates high-quality trivia questions |
| Hosting (Frontend) | Vercel | Free tier, auto-deploys from GitHub |
| Hosting (Backend) | Railway | Free tier, supports WebSockets |
| Hosted Database | Supabase | Free hosted PostgreSQL, no credit card needed |

---

## ğŸ”§ Services Setup

### 1. GitHub
- You already have an account â€” create a new repository called `trivia-game`
- This connects to Vercel and Railway for automatic deploys when you push code

### 2. Supabase (Database)
- Sign up free at [supabase.com](https://supabase.com)
- Create a new project
- Go to **Settings â†’ Database** and copy your connection string
- Run the SQL in the **Database Schema** section below to create your tables
- No credit card required

### 3. Anthropic API (AI Questions)
- Sign up at [console.anthropic.com](https://console.anthropic.com)
- Go to **API Keys** and create a new key
- You'll use the `claude-sonnet-4-20250514` model (cheap, fast, great for trivia generation)
- **Strategy:** Pre-generate questions in bulk with a one-time script and store them in the DB â€” zero API calls during gameplay

### 4. Vercel (Frontend Hosting)
- Sign up free at [vercel.com](https://vercel.com) using your GitHub account
- Import your GitHub repo
- Set the root directory to `/client`
- Add your environment variables (see **Environment Variables** section)
- Every push to GitHub auto-deploys

### 5. Railway (Backend Hosting)
- Sign up free at [railway.app](https://railway.app) using your GitHub account
- Create a new project â†’ Deploy from GitHub repo
- Set the root directory to `/server`
- Add your environment variables
- Railway gives you a public URL â€” copy this into your frontend env vars

---

## ğŸ—‚ï¸ Project Structure

```
trivia-game/
â”œâ”€â”€ client/                    # React frontend
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.jsx            # Simple login/register screen (first thing users see)
â”‚   â”‚   â”‚   â”œâ”€â”€ Home.jsx             # Main menu: "Play with Friends", "Solo", "Leaderboard"
â”‚   â”‚   â”‚   â”œâ”€â”€ Lobby.jsx            # Multiplayer: create/join room, waiting room, player list
â”‚   â”‚   â”‚   â”œâ”€â”€ MultiGame.jsx        # Multiplayer game: Kahoot-style timed questions
â”‚   â”‚   â”‚   â”œâ”€â”€ MultiResults.jsx     # Multiplayer end screen: final leaderboard for that game
â”‚   â”‚   â”‚   â”œâ”€â”€ Solo.jsx             # Solo mode: endless questions, quit anytime
â”‚   â”‚   â”‚   â”œâ”€â”€ SoloResults.jsx      # Solo end screen: correct count, then global leaderboard
â”‚   â”‚   â”‚   â””â”€â”€ Leaderboard.jsx      # Global leaderboard page (standalone)
â”‚   â”‚   â”œâ”€â”€ App.jsx
â”‚   â”‚   â””â”€â”€ main.jsx
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ server/                    # Node.js backend
â”‚   â”œâ”€â”€ index.js               # Entry point: Express + Socket.io setup
â”‚   â”œâ”€â”€ rooms.js               # In-memory multiplayer game state management
â”‚   â”œâ”€â”€ scoring.js             # Kahoot-style score calculator
â”‚   â”œâ”€â”€ db.js                  # PostgreSQL connection pool
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ auth.js            # POST /auth/register, POST /auth/login
â”‚   â”‚   â”œâ”€â”€ questions.js       # GET /questions/random (for solo mode)
â”‚   â”‚   â””â”€â”€ leaderboard.js     # GET /leaderboard, POST /leaderboard (solo score submission)
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ generate-questions.js  # One-time script: uses Claude to fill DB with trivia questions
â”‚
â””â”€â”€ README.md
```

---

## ğŸ—„ï¸ Database Schema

Run this SQL in your Supabase SQL editor:

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE questions (
  id SERIAL PRIMARY KEY,
  question TEXT NOT NULL,
  correct_answer TEXT NOT NULL,
  wrong_answers TEXT[] NOT NULL,       -- array of 3 wrong answers
  category VARCHAR(50),
  difficulty VARCHAR(20) DEFAULT 'medium'
);

-- Global leaderboard: tracks total correct answers across ALL solo games
CREATE TABLE leaderboard (
  user_id INTEGER REFERENCES users(id) PRIMARY KEY,
  username VARCHAR(50) NOT NULL,
  total_correct INTEGER DEFAULT 0,
  games_played INTEGER DEFAULT 0
);
```

**Important distinction:** The global leaderboard only tracks **solo mode** scores. Multiplayer games have their own in-game leaderboard that exists only for the duration of that session (held in server memory). This keeps the two modes cleanly separated.

---

## ğŸ¯ Scoring System (Kahoot-Style)

This is the heart of multiplayer mode. Points reward both correctness and speed.

### The Formula

```javascript
// server/scoring.js

const TIME_LIMIT = 20;         // seconds per question
const MAX_POINTS = 1000;
const MIN_POINTS = 850;

function calculateScore(isCorrect, responseTimeMs) {
  if (!isCorrect) return 0;

  const responseTimeSec = responseTimeMs / 1000;
  const timeRatio = responseTimeSec / TIME_LIMIT;  // 0.0 (instant) to 1.0 (last second)

  // Linear interpolation: faster answers get closer to 1000
  const points = Math.round(MAX_POINTS - (MAX_POINTS - MIN_POINTS) * timeRatio);

  return Math.max(MIN_POINTS, Math.min(MAX_POINTS, points));
}

module.exports = { calculateScore, TIME_LIMIT };
```

### How It Works

| Answer Speed | Points |
|---|---|
| Instant (0s) | 1000 |
| 5 seconds | 963 |
| 10 seconds | 925 |
| 15 seconds | 888 |
| 20 seconds (last moment) | 850 |
| Wrong answer | 0 |
| No answer (time ran out) | 0 |

With 15 questions, the theoretical max score is **15,000 points**. The spread between fastest and slowest correct answer on a single question is only 150 points â€” enough to matter across a full game, but a slow correct answer always beats a wrong one.

---

## ğŸ”Œ How the Two Modes Work

### Login Flow

Every user sees the login screen first. Simple username + password auth with JWT.

```
Login/Register Screen
        â”‚
        â–¼
   Home Screen
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                             â”‚
   â”‚   [ Play with Friends ]     â”‚
   â”‚   [ Solo ]                  â”‚
   â”‚   [ Leaderboard ]           â”‚
   â”‚                             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

After login, the JWT is stored in localStorage and sent with every API request. Socket.io connections also pass the token for identity.

---

### Solo Mode â€” Endless Questions, No WebSockets

Solo is pure HTTP. No rooms, no real-time â€” just fetch, answer, repeat.

**Flow:**

1. Player clicks **Solo** on the home screen
2. Frontend makes `GET /questions/random?count=10` â€” server returns 10 random questions
3. Player answers one question at a time, no timer enforced (casual pace)
4. When 10 questions are used up, frontend silently fetches 10 more in the background â€” the player never sees a loading screen
5. Player can **quit anytime** by pressing a quit button
6. **Solo Results screen** appears showing:
   - Total questions answered
   - Total correct answers
   - Accuracy percentage
7. Server updates the global leaderboard via `POST /leaderboard` with `{ userId, correctCount }`
8. Below the stats, the **global leaderboard** is displayed (top 20 players by total correct answers all-time)

**Why endless?** It differentiates solo from multiplayer. Solo is the chill mode â€” no pressure, no time limit, play during a bus ride. The global leaderboard gives it a reason to keep playing.

---

### Multiplayer Mode â€” Kahoot-Style, 15 Questions, Timed

This is the flagship mode. It works exactly like Kahoot: everyone sees the same question at the same time, has 20 seconds to answer, and gets points based on speed.

**Flow:**

```
 Create Room  â”€â”€orâ”€â”€  Join Room (enter code)
      â”‚                      â”‚
      â–¼                      â–¼
         Lobby (waiting room)
         - Shows player list
         - Host sees "Start Game" button
         - Room code displayed for sharing
                  â”‚
                  â–¼ (host clicks Start)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Question 1/15   â”‚
         â”‚                   â”‚
         â”‚   20s countdown   â”‚
         â”‚                   â”‚
         â”‚   [A]  [B]        â”‚
         â”‚   [C]  [D]        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼ (everyone answered or timer expired)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Answer Reveal     â”‚
         â”‚  Correct: B âœ“      â”‚
         â”‚                   â”‚
         â”‚  Live Standings:  â”‚
         â”‚  1. alice â€” 1963  â”‚
         â”‚  2. bob   â€” 1850  â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼ (repeat x15)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   GAME OVER ğŸ†    â”‚
         â”‚                   â”‚
         â”‚  Final Leaderboard â”‚
         â”‚  1. alice â€” 14,250â”‚
         â”‚  2. bob   â€” 13,100â”‚
         â”‚  3. carol â€” 12,400â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key rules:**
- **15 questions** per game, no more, no less
- **20-second timer** per question, enforced by the server
- **850â€“1000 points** for a correct answer depending on speed; 0 for wrong/timeout
- **Answer reveal** after each question shows the correct answer + current standings
- **Final leaderboard** at the end shows only that game's results (not persisted to DB)
- Multiplayer scores do **not** affect the global leaderboard â€” it's a separate competitive space

---

## ğŸ“¡ Socket.io Events (Multiplayer)

These events are the entire multiplayer protocol. Understanding them is understanding the mode.

```
CLIENT â†’ SERVER:
  create-room     { username }                    â†’ host creates a new room
  join-room       { roomCode, username }          â†’ player joins existing room
  start-game      { roomCode }                    â†’ host starts the game
  submit-answer   { roomCode, answerIndex, timestamp }  â†’ player submits their pick

SERVER â†’ CLIENT:
  room-created    { roomCode }                    â†’ sent to host with their room code
  room-joined     { players }                     â†’ sent to all in room (updated player list)
  player-joined   { username }                    â†’ broadcast when someone new joins
  game-starting   { totalQuestions: 15 }          â†’ countdown before first question
  new-question    { questionIndex, question, options, startTime }  â†’ next question for everyone
  time-up         { }                             â†’ 20 seconds expired, stop accepting answers
  answer-reveal   { correctIndex, scores, standings }  â†’ shows correct answer + updated rankings
  game-over       { finalStandings }              â†’ final leaderboard for the session
  player-left     { username, players }           â†’ someone disconnected
```

### The Question Lifecycle (Server-Side)

Each question goes through this exact sequence on the server:

```
1. Server emits `new-question` to all players with question data + server timestamp
2. Server starts a 20-second timer
3. As answers come in via `submit-answer`, server:
   - Records the answer and calculates response time (server timestamp - startTime)
   - Calculates score using the scoring formula
   - If ALL players have answered, skip to step 4 early
4. Timer expires (or all answered) â†’ server emits `time-up`
5. Server emits `answer-reveal` with:
   - Which answer was correct
   - Points each player earned this round
   - Updated cumulative standings sorted by total score
6. 5-second pause for players to see results
7. If more questions remain â†’ go to step 1
   If question 15 is done â†’ emit `game-over` with final standings
```

**Timing is server-authoritative.** The client shows a countdown for UX, but the server is the source of truth for when time expires and how response time is calculated. This prevents cheating.

---

### In-Memory Game State (server/rooms.js)

All active multiplayer game data lives in server memory. No database needed mid-game.

```javascript
// server/rooms.js

const rooms = {};

// Example of what a room looks like during a game:
rooms["X7K2"] = {
  host: "alice",                      // only this player can start the game
  players: ["alice", "bob", "carol"],
  status: "lobby",                    // "lobby" | "playing" | "finished"
  questions: [ /* 15 question objects fetched from DB at game start */ ],
  currentQuestion: 0,                 // index 0â€“14
  questionStartTime: 1708800000000,   // server timestamp when question was sent
  scores: {                           // cumulative scores for this game session
    alice: 3813,
    bob: 2750,
    carol: 1925
  },
  answers: {                          // answers for the CURRENT question only
    alice: { answerIndex: 2, timestamp: 1708800003200, score: 976 },
    bob: { answerIndex: 1, timestamp: 1708800008500, score: 0 }
    // carol hasn't answered yet
  }
};

// Helper functions to export:
// createRoom(hostUsername) â†’ roomCode
// joinRoom(roomCode, username) â†’ room
// startGame(roomCode, questions) â†’ void
// submitAnswer(roomCode, username, answerIndex, timestamp) â†’ { score, allAnswered }
// advanceQuestion(roomCode) â†’ { question, isGameOver }
// getStandings(roomCode) â†’ sorted array of { username, score }
// deleteRoom(roomCode) â†’ void
```

**Room codes** are random 4-character alphanumeric strings (e.g., "X7K2"). Short enough to share verbally.

---

## ğŸ¤– AI Question Generation with Claude

Run this script once (or whenever you want more questions) to fill your database. No API calls happen during gameplay.

```javascript
// scripts/generate-questions.js
// Run with: node scripts/generate-questions.js

const Anthropic = require('@anthropic-ai/sdk');
const { Pool } = require('pg');

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function generateBatch(batchNumber) {
  const response = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 4000,
    messages: [{
      role: 'user',
      content: `Generate 20 unique trivia questions suitable for a Kahoot-style game. 
      Mix categories: science, history, geography, pop culture, sports, technology, nature, food.
      Make them challenging but fair â€” most adults should have a shot at getting them right.
      
      Respond with ONLY a JSON array, no other text. Each item:
      {
        "question": "the question text",
        "correct": "the correct answer",
        "wrong": ["wrong answer 1", "wrong answer 2", "wrong answer 3"],
        "category": "category name"
      }
      
      IMPORTANT: All 4 answer options should be similar in length and plausibility. 
      Don't make wrong answers obviously silly â€” this is a competitive game.
      This is batch ${batchNumber}, so make sure these are different from common trivia questions.`
    }]
  });

  return JSON.parse(response.content[0].text);
}

async function main() {
  const TOTAL_BATCHES = 10; // 10 batches Ã— 20 questions = 200 questions
  let totalInserted = 0;

  for (let i = 1; i <= TOTAL_BATCHES; i++) {
    console.log(`Generating batch ${i}/${TOTAL_BATCHES}...`);
    
    const questions = await generateBatch(i);

    for (const q of questions) {
      await pool.query(
        'INSERT INTO questions (question, correct_answer, wrong_answers, category) VALUES ($1, $2, $3, $4)',
        [q.question, q.correct, q.wrong, q.category]
      );
      totalInserted++;
    }

    // Small delay between batches to respect rate limits
    if (i < TOTAL_BATCHES) await new Promise(r => setTimeout(r, 2000));
  }

  console.log(`Done! ${totalInserted} questions saved to database.`);
  pool.end();
}

main().catch(console.error);
```

**200 questions** is a good starting point. With 15 questions per multiplayer game and random selection, players would need to play ~13 games before seeing every question. You can always run the script again to add more.

---

## ğŸ” Environment Variables

**Server** â€” create `.env` in `/server` (never commit to GitHub):

```
DATABASE_URL=your_supabase_connection_string
ANTHROPIC_API_KEY=your_anthropic_api_key
JWT_SECRET=any_long_random_string_you_make_up
PORT=4000
```

**Client** â€” create `.env` in `/client`:

```
VITE_SERVER_URL=http://localhost:4000
```

Add these same variables in the Vercel and Railway dashboards under **Environment Variables**. When you deploy, update `VITE_SERVER_URL` to your Railway public URL.

---

## ğŸ—ï¸ Development Roadmap

Work through these phases in order. Each one builds on the last and is independently testable.

### Phase 1 â€” Project Setup (Day 1)

- [ ] Create GitHub repo called `trivia-game`
- [ ] Set up `/client` with Vite + React: `npm create vite@latest client -- --template react`
- [ ] Set up `/server` with Express: `npm init -y` then install dependencies:
  ```bash
  npm install express socket.io cors dotenv pg bcrypt jsonwebtoken @anthropic-ai/sdk
  ```
- [ ] Install Tailwind in client: follow [tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)
- [ ] Verify Express runs on port 4000 and React dev server starts
- [ ] Set up `.env` files for both client and server
- [ ] Add `.env` to `.gitignore`

### Phase 2 â€” Database & Auth (Days 2â€“3)

- [ ] Create Supabase project and run the schema SQL
- [ ] Build `db.js` â€” PostgreSQL connection pool using `DATABASE_URL`
- [ ] Build `POST /auth/register` â€” hash password with bcrypt, insert user, return JWT
- [ ] Build `POST /auth/login` â€” verify password, return JWT
- [ ] Build `Login.jsx` â€” simple form with username/password, toggle between login/register
- [ ] Store JWT in localStorage on successful login
- [ ] Build auth middleware that verifies JWT on protected routes
- [ ] **Test:** register a user, log in, get a token, refresh the page and stay "logged in"

### Phase 3 â€” Question Generation (Day 3)

- [ ] Get your Anthropic API key from [console.anthropic.com](https://console.anthropic.com)
- [ ] Build `scripts/generate-questions.js` using the Claude API (see script above)
- [ ] Run it: `node scripts/generate-questions.js`
- [ ] Verify questions are in your Supabase database (check the table in the Supabase dashboard)
- [ ] Build `GET /questions/random?count=15` route â€” returns N random questions from DB
- [ ] **Important:** This route should shuffle the 4 answer options per question before sending to the client (so the correct answer isn't always in the same position)

### Phase 4 â€” Home Screen & Navigation (Day 4)

- [ ] Build `Home.jsx` â€” three buttons: "Play with Friends", "Solo", "Leaderboard"
- [ ] Set up React Router with routes:
  - `/login` â†’ Login.jsx
  - `/` â†’ Home.jsx (redirects to /login if no JWT)
  - `/solo` â†’ Solo.jsx
  - `/lobby` â†’ Lobby.jsx
  - `/game` â†’ MultiGame.jsx
  - `/results` â†’ MultiResults.jsx
  - `/solo-results` â†’ SoloResults.jsx
  - `/leaderboard` â†’ Leaderboard.jsx
- [ ] Add a simple navbar/header with the player's username and a logout button

### Phase 5 â€” Solo Mode (Days 5â€“6)

- [ ] Build `Solo.jsx`:
  - Fetch 10 questions on mount
  - Display one question at a time with 4 clickable answer buttons
  - After selecting, briefly highlight correct/wrong, then show next question
  - Track correct count and total answered in React state
  - When 8 of 10 questions used, silently fetch 10 more (prefetching)
  - "Quit" button always visible
- [ ] Build `SoloResults.jsx`:
  - Shows total questions answered, correct count, accuracy %
  - On mount, sends `POST /leaderboard` with the player's correct count
  - Fetches and displays the global leaderboard (top 20) below the stats
- [ ] Build `POST /leaderboard` route:
  ```sql
  INSERT INTO leaderboard (user_id, username, total_correct, games_played)
  VALUES ($1, $2, $3, 1)
  ON CONFLICT (user_id)
  DO UPDATE SET 
    total_correct = leaderboard.total_correct + EXCLUDED.total_correct,
    games_played = leaderboard.games_played + 1;
  ```
- [ ] Build `GET /leaderboard` route â€” returns top 20 by `total_correct`
- [ ] Build `Leaderboard.jsx` â€” standalone page accessible from home screen
- [ ] **Test:** play solo, quit after some questions, verify score appears on leaderboard

### Phase 6 â€” Multiplayer: Lobby (Days 7â€“8)

- [ ] Add Socket.io to the server (`index.js`) and client
- [ ] Build `rooms.js` with the in-memory state structure and helper functions
- [ ] Implement `create-room` event:
  - Generate a random 4-character room code
  - Create the room object in memory
  - Join the socket to the Socket.io room
  - Emit `room-created` back with the code
- [ ] Implement `join-room` event:
  - Validate room exists and is in "lobby" status
  - Add player to room
  - Emit `room-joined` to all players with updated player list
- [ ] Build `Lobby.jsx`:
  - "Create Room" button â†’ emits `create-room`, shows room code prominently
  - "Join Room" input + button â†’ emits `join-room` with entered code
  - Shows list of players currently in the room
  - Host sees a "Start Game" button (only enabled with 2+ players)
  - Non-hosts see "Waiting for host to start..."
- [ ] Handle disconnections â€” remove player from room, emit `player-left`
- [ ] **Test:** open two browser tabs, create a room in one, join in the other, see both names appear

### Phase 7 â€” Multiplayer: Game (Days 9â€“11)

- [ ] Implement `start-game` event:
  - Validate sender is host
  - Fetch 15 random questions from DB
  - Store in room state, set status to "playing"
  - Emit `game-starting` with a 3-second countdown
  - After countdown, emit first `new-question`
- [ ] Build the question timer on the server:
  - When `new-question` is emitted, start a 20-second `setTimeout`
  - On timeout, emit `time-up` and then `answer-reveal`
  - If all players answer before timeout, clear the timer and reveal immediately
- [ ] Implement `submit-answer` event:
  - Record the answer with server-calculated response time
  - Calculate score using `scoring.js`
  - Check if all players have answered â†’ if yes, trigger early reveal
- [ ] Build the `answer-reveal` emission:
  - Include: correct answer index, points earned per player, sorted standings
- [ ] Build the `game-over` emission:
  - Include: final standings sorted by score
  - Set room status to "finished"
  - Clean up room from memory after a delay
- [ ] Build `MultiGame.jsx`:
  - Receives `new-question` â†’ shows question + 4 colored answer buttons + countdown timer
  - On answer click â†’ emit `submit-answer`, disable buttons, show "waiting for others..."
  - Receives `time-up` â†’ disable buttons if not already answered
  - Receives `answer-reveal` â†’ highlight correct answer, show points earned, show standings
  - After 5 seconds â†’ ready for next question
  - Receives `game-over` â†’ navigate to results
- [ ] Build `MultiResults.jsx`:
  - Shows the final game leaderboard with podium-style display
  - ğŸ¥‡ ğŸ¥ˆ ğŸ¥‰ for top 3
  - Shows each player's total score
  - "Play Again" button (returns to lobby) and "Home" button
- [ ] **Test:** open 2-3 tabs, play a full 15-question game, verify scores calculate correctly and leaderboard shows the right winner

### Phase 8 â€” Polish & Deploy (Days 12â€“14)

- [ ] **UI Polish:**
  - Color-coded answer buttons (red, blue, green, yellow â€” like Kahoot)
  - Animated countdown timer (circular progress or shrinking bar)
  - Smooth transitions between questions
  - Score popup animation when points are earned (+976!)
  - Podium animation on the final results screen
  - Responsive design â€” should work on phones (friends will play on their phones)
- [ ] **Edge Cases:**
  - Handle player disconnect mid-game (remove from room, continue game for others)
  - Handle host disconnect (promote next player or end game)
  - Prevent joining a room that's already in-game
  - Handle the case where a room has only 1 player left
- [ ] **Error Handling:**
  - Loading spinners on all async operations
  - Toast notifications for errors (room not found, connection lost, etc.)
  - Reconnection logic for Socket.io
- [ ] **Deploy:**
  - Push everything to GitHub
  - Deploy backend to Railway, copy the public URL
  - Update `VITE_SERVER_URL` in client `.env` to the Railway URL
  - Deploy frontend to Vercel
  - Test the live URL end-to-end â€” including on your phone
  - Write a README with: live demo link, screenshots, tech stack, architecture overview

---

## ğŸ’¬ Interview Talking Points

Practice saying these naturally. They demonstrate real technical depth and design thinking â€” exactly what an interviewer wants to hear from a new grad.

**"Walk me through the architecture."**
> It's a two-mode trivia app. Solo mode is stateless REST â€” the client fetches questions, the player answers at their own pace, and the score gets posted at the end. Multiplayer is a real-time system built on Socket.io where the server acts as the authoritative game host â€” it controls timing, validates answers, calculates scores, and pushes state to all connected clients simultaneously. I deliberately separated the two modes because they have fundamentally different requirements, and it let me build and test solo without touching WebSockets.

**"Why is timing server-authoritative?"**
> In a competitive game where score depends on response time, you can't trust the client's clock. Two players could have different system times, or someone could manipulate their local timestamps. So the server records when it sent the question, and when each answer arrives â€” the response time is calculated server-side. The client countdown is just a visual aid.

**"How does the Kahoot-style scoring work?"**
> Correct answers earn between 850 and 1000 points based on response time â€” it's a linear interpolation over the 20-second window. I chose 850 as the floor so that a slow correct answer still significantly beats a wrong answer (which scores 0). The 150-point spread per question means speed matters across a full 15-question game, but knowledge is always more valuable than reflexes.

**"Why is the multiplayer leaderboard not persisted?"**
> Design decision. The multiplayer leaderboard only exists for that session â€” it's a competition between the people in the room. Persisting it would mix competitive real-time scores with the solo grind leaderboard, which are fundamentally different. Solo rewards consistency over time. Multiplayer rewards performance in a single high-pressure session. Keeping them separate makes each mode's leaderboard meaningful.

**"How do you handle a player disconnecting mid-game?"**
> Socket.io fires a `disconnect` event. The server removes that player from the room's active player list and checks if all remaining players have answered the current question â€” if so, it advances immediately. If the host disconnects, the next player becomes host. If only one player is left, the game continues so they can finish, but it's effectively solo at that point.

**"How would you scale this?"**
> Right now room state lives in server memory, which limits me to a single instance. To scale horizontally, I'd move room state to Redis using its pub/sub for cross-instance Socket.io communication (there's an official adapter: `@socket.io/redis-adapter`). The REST endpoints and database are already stateless, so they'd scale behind a load balancer with no changes. I'd also add a question cache layer so the DB isn't hit every time a game starts.

**"Why Claude for question generation instead of a trivia API?"**
> Two reasons. First, I have full control over the question format, difficulty, and answer plausibility. Public trivia APIs often have obviously wrong answers that make the game too easy. With Claude, I can prompt for answers that are all similar in length and plausibility, which makes the game more competitive. Second, it demonstrates API integration with an AI service, which is a relevant skill for modern development.

---

## ğŸ“ Useful Links

- [Socket.io Docs](https://socket.io/docs/v4/)
- [Anthropic Claude API Docs](https://docs.anthropic.com/en/docs/initial-setup)
- [Supabase Quickstart](https://supabase.com/docs/guides/database/connecting-to-postgres)
- [Railway Deployment Guide](https://docs.railway.app/guides/deployments)
- [Vercel Deployment Guide](https://vercel.com/docs/deployments/overview)
- [Tailwind CSS Docs](https://tailwindcss.com/docs)
- [React Router Docs](https://reactrouter.com/en/main)
- [bcrypt npm](https://www.npmjs.com/package/bcrypt)
- [jsonwebtoken npm](https://www.npmjs.com/package/jsonwebtoken)
- [@anthropic-ai/sdk npm](https://www.npmjs.com/package/@anthropic-ai/sdk)

---

## ğŸ“ Why This Project Stands Out on a Resume

This isn't a tutorial project. Here's what makes it impressive:

1. **Real-time multiplayer** â€” most student projects are CRUD apps. WebSockets demonstrate you understand bidirectional communication, state synchronization, and event-driven architecture.

2. **Server-authoritative game logic** â€” you made deliberate anti-cheat decisions (server-side timing, server-calculated scores). This shows you think about trust boundaries.

3. **AI integration** â€” you used an LLM API for practical content generation, not just a chatbot wrapper. You can talk about prompt engineering for structured output.

4. **Scoring algorithm design** â€” you can explain the math behind the 850â€“1000 point range and why you chose those numbers. This shows product thinking.

5. **Two distinct architectural patterns** in one app â€” REST for solo, WebSockets for multiplayer. You can compare them and explain when each is appropriate.

6. **Full deployment pipeline** â€” GitHub â†’ Vercel/Railway with environment variables, database hosting, CI/CD. You've shipped something real, not just `localhost:3000`.

When you demo this in an interview, pull it up on your phone, have the interviewer join on their laptop, and play a game together. Nothing sells a project like a live demo.

---

*Build it phase by phase, test as you go, and have fun with it. The moment two browser tabs are racing to answer the same question at the same time â€” that's when it clicks.*
